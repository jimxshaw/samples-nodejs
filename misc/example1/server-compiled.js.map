{"version":3,"sources":["server.js"],"names":[],"mappings":"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","file":"server-compiled.js","sourcesContent":["var http = require(\"http\");\nvar querystring = require(\"querystring\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar url = require(\"url\");\n\nvar directory = \"./documents\";\n\n// Regular expression to securitize url paths.\nvar invalidFileRegex = /^[.\\/\\\\]|\\.\\./;\n\n// Create a simple http web server. It takes a callback that accepts\n// a request and returns a response. The server is a stream. To stop\n// it, we have to call .end method or it will continue to run indefinitely.\nvar server = http.createServer(function(req, res) {\n    // Detects the method of form submission, either through the url (GET)\n    // or submit button (POST) and execute a specific method to handle each.\n    if (req.method === \"POST\") {\n        handlePost(req, res);\n        return;\n    }\n\n    // Parse out the request's url query string.\n    var query = url.parse(req.url, true).query;\n\n    if (query.file) {\n        writeFile(req, res, query);\n        return;\n    }\n\n    writeIndex(req, res);\n});\n\n// This is the function to write out the file contents from the documents\n// directory.\nfunction writeIndex(req, res) {\n    // It's important to tell the browser that we're going to pass in html\n    // so it'll render html. Http response status code of 200 means OK.\n    res.writeHead(200, {\"Content-Type\": \"text/html\"});\n\n    fs.readdir(directory, function(err, files) {\n        // If an error appears, end the server immediately and exit the function.\n        if (err) {\n            res.end(err);\n            return;\n        }\n\n        // Declare a variable that will be used in our template string later.\n        var fileListHtml = \"\";\n        for (var i = 0; i < files.length; i++) {\n            var file = files[i];\n\n            // The ?file is the query string that specifies a particular file.\n            // When an a tag has a ?= that means when it's clicked, it'll replace\n            // whatever query string that's there with that query string.\n            fileListHtml += `<li><a href=\"?file=${file}\">${file}</a></li>`;\n        }\n\n\n        // Template strings use backticks, the symbol next to 1 key. Keep in mind\n        // that backticks allow for multi-line template strings and javascript\n        // // expressions, signified by ${}.\n        res.end(`\n            <ul>\n                ${fileListHtml}\n            </ul>\n            <form method=\"POST\">\n                <input type=\"text\" name=\"file\"/>\n                <textarea name=\"text\"></textarea>\n                <input type=\"submit\" />\n            </form>\n        `);\n    });\n}\n\nfunction writeFile(req, res, query) {\n    // If users try to input a malicious url query string, send back a particular\n    // response.\n    if (invalidFileRegex.test(query.file)) {\n        writeText(res, 400, \"Invalid filename\");\n        return;\n    }\n\n    // Create the full filename.\n    var filename = path.join(directory, query.file);\n\n    fs.readFile(filename, function(err, buffer) {\n        if (err) {\n            writeText(res, 400, err);\n            return;\n        }\n\n        // If no error, write out with a status of 200, OK and get the contents\n        // of the file out with buffer.\n        writeText(res, 200, buffer.toString());\n    });\n}\n\n// POST requests are handled here.\nfunction handlePost(req, res) {\n    // Capture all of the request body data. The request object is a stream from the browser,\n    // it will stream in the data as it happens. We need to handle this asynchronously.\n    var body = \"\";\n\n    // Think of the req stream as the read stream while the res stream is the write stream.\n    // Because req is a read stream, we can add an .on method event handler. The event\n    // handler of \"data\" will be invoked every time the browser is sending more data to\n    // the server, aggregate the data as it flows in.\n    req.on(\"data\", function(data) {\n        body += data;\n    });\n\n    // When the browser indicates to the server that there's no more data to send, we need\n    // to handle and process the data that we accumulated from all these data events.\n    req.on(\"end\", function() {\n        var form = querystring.parse(body);\n\n        // If the user didn't provide a file name or the file name is tested to be invalid\n        // by our security regular expression, send back a status of 400 bad request.\n        if (!form.file || invalidFileRegex.test(form.file)) {\n            writeText(res, 400, \"Invalid Path\");\n            return;\n        }\n\n        // The writeFileSync is wrapped in a try-catch block. If anything goes wrong, the\n        // block will proc and an appropriate message is sent back. If it succeeds then\n        // kick off the writeIndex function that writes the file into the index page.\n        try {\n            fs.writeFileSync(path.join(directory, form.file), form.text);\n            writeIndex(req, res);\n        }\n        catch (ex) {\n            writeText(res, 400, \"Could not save file\");\n            console.error(ex);\n        }\n    });\n}\n\n// This is used in case of errors. It will write out a head of a specified http\n// status code of content-type plain text and then write out some text.\nfunction writeText(res, status, text) {\n    res.writeHead(status, {\"Content-Type\": \"text/plain\"});\n    res.end(text);\n}\n\n// List the port where the web server will listen to requests.\nserver.listen(8000, function() {\n    console.log(\"Listening on port 8000...\");\n});"]}